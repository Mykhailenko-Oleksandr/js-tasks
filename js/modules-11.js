/**
 * HTTP-запити
 *
 * Fetch API
 * - Метод fetch()
 *
 * Вкладка Network
 *
 * Перевірка відповіді
 * - json()
 * - text()
 * - blob()
 *
 * HTTP-методи
 * - POST
 * - GET
 * - PUT
 * - PATCH
 * - DELETE
 *
 * HTTP-заголовки
 * - User-Agent
 * - Accept
 * - Content-Type
 * - Authorization
 * - Cache-Control
 * - Host
 *
 * Кросдоменні запити
 *
 * Оновлення інтерфейсу
 *
 * Параметри рядка запиту
 *
 * Бібліотека Axios
 */





/////////////////////////////////////////////// Fetch API ////////////////////////////////////////////////////////

// Fetch API — це вбудований у браузер інтерфейс, доступний через об'єкт window.
// Він дозволяє відправляти HTTP-запити на сервер і обробляти відповіді.

// Метод fetch() забезпечує сучасний підхід до роботи з мережею та побудований на промісах.


//     fetch(url, options)


// url — шлях до ресурсу на сервері(обов’язковий параметр).
//     options — об’єкт із додатковими налаштуваннями запиту(наприклад, метод, заголовки, тіло тощо).

// JSONPlaceholder API — це тестовий REST API, який містить колекції фіктивних даних, наприклад список користувачів(/users).


// fetch("https://jsonplaceholder.typicode.com/users")
//     .then(response => {
//         // Response handling
//     })
//     .then(data => {
//         // Data handling
//     })
//     .catch(error => {
//         // Error handling
//     });


// Як працює цей код ?

//  fetch() відправляє запит на сервер і повертає проміс.
//  then(response => {...}) виконується, коли відповідь отримано.
//  then(data => {...}) обробляє отримані дані.
//  catch(error => {...}) виконується у разі помилки.





/////////////////////////////////////////////// Вкладка Network ////////////////////////////////////////////////////////

// Коди відповідей

// Коди діляться на групи залежно від того, з якої цифри починається код помилки.

// 1XX — мають інформаційне призначення
// 2XX — коди успішного проведення операції
// 3XX — описують усе, що пов'язано з перенаправленням (redirect)
// 4XX — вказують на помилки з боку клієнта
// 5XX — вказують на помилки з боку сервера

// Немає потреби пам'ятати всі коди з кожної групи, достатньо знати найпоширеніші. Решту завжди можна подивитися в довіднику HTTP-кодів.

// 200(OK) — стандартна відповідь для успішних HTTP - запитів.
// 201(Created) — стандартна відповідь для HTTP - запиту, який привів до успішного створення ресурсу.
// 400(Bad Request) — запит не може бути оброблений через неправильний синтаксис запиту або іншу помилку клієнта.
// 401(Unauthorized) — для доступу до ресурсу вимагається авторизація.
// 403(Forbidden) — у клієнта немає дозволу на доступ до цього ресурсу.
// 404(Not Found) — у цей час ресурс не знайдений.Можливо, він був видалений або ще не існує.
// 500(Internal Server Error) — загальна відповідь на непередбачений збій сервера, якщо відсутня конкретніша інформація.






/////////////////////////////////////////////// Перевірка відповіді ////////////////////////////////////////////////////////

// Метод fetch() повертає проміс, значенням якого є об'єкт Response. Це службовий об'єкт, що містить інформацію про стан
// відповіді сервера та методи для обробки отриманих даних.

// Залежно від типу контенту використовуються різні методи для перетворення даних у зручний формат:

// json() — парсить відповідь у форматі JSON.
// text() — парсить відповідь у вигляді тексту(наприклад табличні дані, .csv).
// blob() — використовується для обробки файлів(зображення, аудіо, відео).

// За замовчуванням fetch() не вважає HTTP - коди 404 чи 500 помилками.Тому потрібно вручну перевіряти статус відповіді
// та створювати помилку для обробки в catch ().


// fetch("https://jsonplaceholder.typicode.com/users")
//     .then(response => {
//         if (!response.ok) {
//             throw new Error(`HTTP error! Status: ${response.status}`);
//         }
//         return response.json();
//     })
//     .then(data => {
//         // Data handling
//         console.log("Отримані дані:", data);
//     })
//     .catch(error => {
//         // Error handling
//         console.log("Помилка запиту:", error);
//     });


// Чому це важливо ?

//     fetch() не відхиляє проміс при помилках сервера(наприклад, 404 або 500).
// Щоб виявити невдалий запит, потрібно вручну перевіряти response.ok.
// Якщо response.ok === false, необхідно викликати throw new Error(), щоб помилка оброблялася в catch ().

// Такий підхід дозволяє коректно реагувати на помилки та уникати несподіваної поведінки в коді.







/////////////////////////////////////////////// HTTP-методи ////////////////////////////////////////////////////////

// У REST API використовується кілька основних HTTP - методів для взаємодії з ресурсами:

// POST — створює новий ресурс.
// GET — отримує набір ресурсів або один ресурс.
// PUT — оновлює існуючий ресурс або створює новий.
// PATCH — частково оновлює існуючий ресурс.
// DELETE — видаляє ресурс.

// Наразі нас цікавить GET, який використовується для отримання даних із сервера.

// Метод запиту задається через об’єкт налаштувань, який передається другим аргументом у fetch():


// const options = {
//     method: "GET"
// };

// fetch("https://jsonplaceholder.typicode.com/users", options)
//     .then(response => {
//         if (!response.ok) {
//             throw new Error(response.status);
//         }
//         return response.json();
//     })
//     .then(data => {
//         // Data handling
//     })
//     .catch(error => {
//         // Error handling
//     });


// Важливі нюанси

// Якщо виконується GETзапит, вказувати method: "GET" не обов’язково, оскільки це значення за замовчуванням.
// Доступні HTTP - методи для кожного ресурсу описані у документації бекенду.

// Використання правильного HTTP - методу гарантує, що сервер обробить запит очікуваним чином.







/////////////////////////////////////////////// HTTP-заголовки ////////////////////////////////////////////////////////

// HTTP - заголовки містять службову інформацію, що описує запит або відповідь.Кожен заголовок складається з імені та значення.
// Наприклад:

// Accept — визначає тип контенту, який клієнт може прийняти у відповіді.
// Content - Type — вказує тип контенту, щоб отримувач знав, як його обробити.

// Accept: text / html
// Content - Type: application / json

// Заголовок складається з імені та значення.Значення заголовка — це MIME - тип(тип контенту), який використовується для
// вказівки типу контенту запиту чи відповіді і складається з типу і підтипу, розділених косою рискою(/).

//     Наприклад:

// text/html — HTML-файл.
// text/css — CSS-файл.
// application/json — JSON-дані.

// Якщо клієнт очікує text / css, а отримує application / json, він не зможе правильно обробити відповідь.
// Тому заголовки допомагають серверу і клієнту погоджувати формат переданих даних.


// Як переглянути заголовки у браузері ?
// У вкладці Network(інструменти розробника) заголовки відповіді видно в секції Response Headers, а заголовки запиту — у Request Headers.


// Як передати заголовки у fetch() ?
// Заголовки додаються у властивість headers об’єкта налаштувань:

// fetch("some-url", {
//     headers: {
//         "Content-Type": "application/json",
//         "X-Custom-Header": "custom value",
//     }
// })

// Якщо потрібно вказати, що ми очікуємо відповідь у форматі JSON, додаємо Accept: application / json:

// fetch("https://jsonplaceholder.typicode.com/users", {
//     headers: {
//         Accept: "application/json",
//     },
// }).then(response => {
//     // ...
// });


// Стандартні заголовки

// Сучасні браузери автоматично додають деякі заголовки, тому їх не потрібно вказувати вручну.Ось найпоширеніші з них:

// User-Agent — ідентифікує браузер або інший клієнтський застосунок.
// Accept — вказує, які формати даних клієнт може обробляти.
// Content-Type — вказує тип контенту в тілі запиту або відповіді.
// Authorization — використовується для передачі токенів аутентифікації.
// Cache-Control — керує кешуванням відповіді.
// Host — містить доменне ім’я сервера, до якого виконується запит.


// Заголовки відіграють ключову роль у взаємодії клієнта та сервера, дозволяючи налаштовувати формат переданих даних
// і механізми автентифікації.






/////////////////////////////////////////////// Кросдоменні запити ////////////////////////////////////////////////////////

// За замовчуванням браузери дозволяють виконувати HTTP - запити тільки в межах поточного сайту.
// Якщо запит робиться на інший домен, порт або протокол, браузер блокує його та видає помилку.

// Ця політика безпеки називається CORS(Cross - Origin Resource Sharing), що перекладається як "спільне використання
// ресурсів між різними джерелами".

// Як працює CORS ?
// При кожному HTTP - запиті браузер автоматично додає заголовок Origin, де вказує адресу вебсторінки, яка намагається отримати дані.

// Приклад запиту з вебсторінки https://my-site.com/about на сервер https://my-api.com/users

// GET / users
// Host: my - api.com
// Origin: https://my-site.com

// Сервер перевіряє заголовок Origin і, якщо він дозволяє кросдоменні запити, додає у відповідь спеціальний заголовок
// Access - Control - Allow - Origin.


// # Доступ тільки для одного сайту
// Access - Control - Allow - Origin: https://my-site.com

// # Доступ для всіх(публічний API)
// Access - Control - Allow - Origin: *


// Як сервер обробляє CORS ?
// Якщо Access - Control - Allow - Origin містить конкретний сайт, тільки він може отримати відповідь.
// Якщо значення *, запити дозволені з будь - якого джерела.
// Якщо цей заголовок відсутній, браузер блокує відповідь, і JavaScript - код отримає помилку CORS.


// Браузер виступає посередником між JavaScript - кодом і сервером:

// Додає заголовок Origin до запиту.
// Перевіряє відповідь сервера на наявність Access - Control - Allow - Origin.
// Якщо заголовок присутній і збігається — запит виконується успішно.
// Якщо ні — браузер блокує відповідь і викидає помилку CORS.

//     Висновок
// CORS налаштовується на бекенді.Якщо сервер не підтримує кросдоменні запити, фронтенд - розробник не може змінити це у своєму коді.
// Якщо при виконанні запиту виникає помилка CORS, необхідно перевірити налаштування бекенду та дозволи на доступ.






/////////////////////////////////////////////// Оновлення інтерфейсу ////////////////////////////////////////////////////////

// HTML - розмітка:

// <button type="button" class="btn">Fetch users</button>
// <ul class="user-list"></ul>

// При кліку на кнопку Fetch users виконаємо HTTP - запит:


// const fetchUsersBtn = document.querySelector(".btn");

// fetchUsersBtn.addEventListener("click", () => {
//     fetch("https://jsonplaceholder.typicode.com/users")
//         .then((response) => {
//             if (!response.ok) {
//                 throw new Error(response.status);
//             }
//             return response.json();
//         })
//         .then((users) => {
//             // Дані від бекенда
//             console.log(users);
//         })
//         .catch((error) => console.log(error));
// });


// У другому блоці then отримуємо доступ до даних відповіді від бекенда.Саме тут можна використати ці дані й оновити інтерфейс,
// створити HTML - розмітку і додати її в DOM у якийсь уже наявний елемент.

// Для створення HTML - розмітки можна використовувати будь - який зручний спосіб, наприклад createElement або insertAdjacentHTML.
// Розглянемо одну зі стандартних технік.

// Перебираємо масив об'єктів методом map
// На кожній ітерації повертаємо HTML - розмітку для одного елемента колекції
// Результуючий масив рядків зшиваємо в один рядок методом join("")
// Додаємо рядок з HTML - розміткою в DOM методом insertAdjacentHTML


// const fetchUsersBtn = document.querySelector(".btn");
// const userList = document.querySelector(".user-list");

// fetchUsersBtn.addEventListener("click", () => {
//     fetch("https://jsonplaceholder.typicode.com/users")
//         .then((response) => {
//             if (!response.ok) {
//                 throw new Error(response.status);
//             }
//             return response.json();
//         })
//         .then((users) => {
//             const markup = users.map((user) => {
//                 return `<li>
// 	          <p><b>Name</b>: ${user.name}</p>
// 	          <p><b>Email</b>: ${user.email}</p>
// 	          <p><b>Company</b>: ${user.company.name}</p>
// 	        </li>`;
//             })
//                 .join("");

//             userList.insertAdjacentHTML("beforeend", markup);
//         })
//         .catch((error) => console.log(error));
// });


// Розбери живий приклад написаного коду.Зверни увагу, як ми покращили код, щоб зробити його більш читабельним.

// Винесли код запиту у функцію fetchUsers(), яка виконує HTTP - запит і повертає результат - проміс, який в свою чергу повернув метод then.
// В обробнику події кліка ми її викликаємо і до результату її виклику(промісу) додаємо ланцюжок методів then() і catch ().
// Винесли код створення й додавання HTML - розмітки у функцію renderUsers(users), яка очікує масив користувачів.


// const fetchUsersBtn = document.querySelector(".btn");
// const userList = document.querySelector(".user-list");

// fetchUsersBtn.addEventListener("click", () => {
//     fetchUsers()
//         .then((users) => renderUsers(users))
//         .catch((error) => console.log(error));
// });

// function fetchUsers() {
//     return fetch("https://jsonplaceholder.typicode.com/users").then(
//         (response) => {
//             if (!response.ok) {
//                 throw new Error(response.status);
//             }
//             return response.json();
//         }
//     );
// }

// function renderUsers(users) {
//     const markup = users
//         .map((user) => {
//             return `<li>
//           <p><b>Name</b>: ${user.name}</p>
//           <p><b>Email</b>: ${user.email}</p>
//           <p><b>Company</b>: ${user.company.name}</p>
//         </li>`;
//         })
//         .join("");
//     userList.insertAdjacentHTML("beforeend", markup);
// }






/////////////////////////////////////////////// Параметри рядка запиту ////////////////////////////////////////////////////////

// Параметри запиту дозволяють передавати на бекенд додаткові критерії для отримання потрібних даних.
// Вони можуть використовуватися для:

// Обмеження кількості результатів(наприклад, отримати лише 7 записів).
// Сортування за певною властивістю(наприклад, за іменем або датою).
// Фільтрації результатів за певними умовами.

// Список доступних параметрів запиту залежить від бекенду і зазвичай описаний у його документації.

// Синтаксис параметрів у URL

// Параметри додаються після?.
// Кожен параметр — це пара ключ = значення.
// Кілька параметрів розділяються символом &.

// У документації JSONPlaceholder API вказано такі параметри:

// _limit — обмежує кількість записів у відповіді.
// _sort — сортує отримані дані за вказаним полем.

// Підкреслення в іменах параметрів специфічні для цього бекенда, це не якийсь стандарт.


// fetch("https://jsonplaceholder.typicode.com/users?_limit=7&_sort=name")


// Що робить цей запит ?
// Повертає 7 користувачів(замість 10, які є за замовчуванням).
// Відсортовує їх за полем name в алфавітному порядку.


// Нижче ми додали використання параметрів рядка запиту до живого прикладу.


// const fetchUsersBtn = document.querySelector(".btn");
// const userList = document.querySelector(".user-list");

// fetchUsersBtn.addEventListener("click", () => {
//     fetchUsers()
//         .then((users) => renderUsers(users))
//         .catch((error) => console.log(error));
// });

// function fetchUsers() {
//     return fetch(
//         "https://jsonplaceholder.typicode.com/users?_limit=7&_sort=name"
//     ).then((response) => {
//         if (!response.ok) {
//             throw new Error(response.status);
//         }
//         return response.json();
//     });
// }

// function renderUsers(users) {
//     const markup = users
//         .map((user) => {
//             return `
//           <li>
//             <p><b>Name</b>: ${user.name}</p>
//             <p><b>Email</b>: ${user.email}</p>
//             <p><b>Company</b>: ${user.company.name}</p>
//           </li>
//       `;
//         })
//         .join("");
//     userList.insertAdjacentHTML("beforeend", markup);
// }







/////////////////////////////////////////////// Бібліотека Axios ////////////////////////////////////////////////////////

// Встановлення

// Axios — це потужний HTTP - клієнт, який базується на Promise та спрощує роботу з HTTP - запитами.Він дозволяє:

// Зберігати глобальні налаштування — вони автоматично застосовуватимуться до всіх запитів.
// Автоматично конвертувати дані — Axios сам перетворює запити у JSON.
// Парсити відповіді — не потрібно викликати response.json(), як у fetch.
// Обробляти всі помилки — включаючи HTTP - статуси, такі як 404.

// Axios — це зручна альтернатива стандартному Fetch API.


// Встановити бібліотеку можна через NPM:

// npm install axios

// Після встановлення імпортуй її у своєму JavaScript - файлі:

// import axios from 'axios';

// Тепер можна використовувати Axios для виконання HTTP - запитів!



// Синтаксис запиту

// Щоб зробити HTTP - запит, достатньо викликати axios і передати об'єкт конфігурації. Наприклад, ось як можна виконати GET-запит:


// import axios from "axios";

// axios({
//     method: 'get',
//     url: 'https://jsonplaceholder.typicode.com/users'
// });


// Функція axios повертає проміс, який можна обробити стандартними методами then і catch:


// import axios from "axios";

// axios({
//     method: 'get',
//     url: 'https://jsonplaceholder.typicode.com/users'
// })
//     .then(response => console.log(response))
//     .catch(error => console.log(error));


// На відміну від fetch:

// Не потрібно вручну парсити JSON – Axios автоматично перетворює відповідь у формат JSON, не потрібно парсити дані
// відповіді методом response.json().
// Автоматична обробка помилок – проміс відхиляється при будь - якому невдалому HTTP - коді відповіді(наприклад, 404),
// тому перевіряти response.ok не потрібно.

// Це значно спрощує код взаємодії з бекендом!



// Псевдоніми методів запиту

// Axios пропонує зручні псевдоніми(скорочені методи) для всіх підтримуваних HTTP - запитів.
// Вони спрощують синтаксис і додають стандартні налаштування.

// Візьмемо вже відомий нам код GET - запиту.


// import axios from "axios";

// axios({
//     method: 'get',
//     url: 'https://jsonplaceholder.typicode.com/users'
// })
//     .then(response => console.log(response))
//     .catch(error => console.log(error))


// Однак Axios дозволяє використовувати зручніший метод axios.get(url[, config]).Квадратні дужки позначають необов'язковий
// аргумент у документації і не є частиною коду.


// import axios from "axios";

// axios.get('https://jsonplaceholder.typicode.com/users')
//     .then(response => console.log(response))
//     .catch(error => console.log(error))


// Використання axios.get позбавляє необхідності явно вказувати метод запиту — GET підставляється автоматично.
// Axios додає стандартні HTTP - заголовки, наприклад, Accept: application / json, оскільки зазвичай сервер повертає дані у форматі JSON.

// Таким чином, код стає більш лаконічним і зручним для використання!

// Який метод бібліотеки Axios виконає GET запит ?



//     Об'єкт відповіді

// Коли Axios виконує HTTP - запит, він повертає об'єкт відповіді, який містить наступну інформацію:

// {
//     data: { },       // Відповідь від сервера
//     status: 200,    // Код стану HTTP
//         statusText: "OK", // Текстовий опис статусу
//             headers: { },    // Заголовки відповіді
//     config: { },     // Конфігурація запиту
//     request: { }     // Об'єкт самого запиту
// }


// Опис ключових властивостей:

// data — містить тіло відповіді від сервера.
// status — HTTP - код відповіді(наприклад, 200 для успішного запиту).
// statusText — текстове повідомлення, пов’язане з кодом статусу.
// headers — об'єкт HTTP-заголовків, отриманих у відповіді.
// config — конфігурація, яка використовувалася при виконанні запиту.
// request — сам запит, який був надісланий.

// При використанні then ми отримуємо об'єкт відповіді та можемо звертатися до його властивостей:


// import axios from "axios";

// axios.get('https://jsonplaceholder.typicode.com/users')
//     .then(response => {
//         console.log(response.data);
//         console.log(response.status);
//         console.log(response.statusText);
//         console.log(response.headers);
//         console.log(response.config);
//     })
//     .catch(error => {
//         console.log(error);
//     })


// Чому Axios зручніший за fetch ?

// Автоматичний парсинг JSON – немає потреби викликати response.json(), як у fetch.Дані вже знаходяться у response.data.
// Автоматична перевірка статусу відповіді – Axios автоматично відхиляє проміс у разі помилки(404, 500 тощо).У fetch довелося б вручну перевіряти response.ok.



// Конфігурація за замовчуванням

// Якщо у тебе є кілька запитів до одного сервера, доводиться щоразу повторювати базову
// адресу(https://jsonplaceholder.typicode.com), що робить код менш зручним:


// axios.get("https://jsonplaceholder.typicode.com/users").then().catch();
// axios.get("https://jsonplaceholder.typicode.com/posts").then().catch();
// axios.get("https://jsonplaceholder.typicode.com/images").then().catch();


// Можна вказати стандартні налаштування конфігурації у властивості axios.defaults, які будуть застосовані до всіх запитів.
// Властивість axios.defaults.baseURL відповідає за збереження базової адреси для всіх HTTP - запитів.


// import axios from "axios";

// axios.defaults.baseURL = 'https://jsonplaceholder.typicode.com';


// Після цього у запитах можна вказувати лише відносний шлях.Axios автоматично додає baseURL до кожного запиту.


// import axios from "axios";

// axios.defaults.baseURL = "https://jsonplaceholder.typicode.com";

// axios.get("/users").then().catch();
// axios.get("/posts").then().catch();
// axios.get("/images").then().catch();


// Таким чином, якщо тобі потрібно змінити API - адресу, достатньо оновити axios.defaults.baseURL в одному місці.

// Це робить код гнучкішим та зручнішим!

// У якій властивості зберігається загальна конфігурація для всіх запитів ?




// Заголовки за замовчуванням

// Окрім базової адреси, можна також встановити стандартні заголовки для всіх HTTP - запитів.Це корисно, якщо,
// наприклад, потрібно передавати API - ключ або інші авторизаційні дані в кожному запиті.

// Використовуємо axios.defaults.headers.common для встановлення заголовків, які будуть застосовуватися до всіх запитів:


// import axios from "axios";

// const myApiKey = "secret-api-key-for-every-request";

// axios.defaults.headers.common["header-name"] = myApiKey;


// Як це працює ?
// Замість "header-name" вказується потрібний заголовок, наприклад, "Authorization", "X-API-Key" тощо.
// Axios додає цей заголовок та його значення до кожного запиту, що позбавляє необхідності передавати його вручну щоразу.

// Таким чином, заголовки додаються автоматично без дублювання коду, що робить його чистішим та зручнішим для підтримки!

// У якій властивості зберігаються стандартні заголовки для всіх запитів ?




// Параметри рядка запиту

// Коли потрібно передати параметри в URL, їх можна додати різними способами.Якщо параметрів багато, це може
// зробити код менш читабельним і незручним для редагування.

// Передача параметрів безпосередньо в URL.Цей підхід працює, але з великою кількістю параметрів URL стає громіздким і складним для читання.


//     axios.get("https://jsonplaceholder.typicode.com/users?_limit=7&_sort=name");


// Можна створити параметри у вигляді об'єкта за допомогою класу URLSearchParams, а потім передати їх у запит:


// const searchParams = new URLSearchParams({
//     _limit: 5,
//     _sort: "name",
// });

// axios.get(`https://jsonplaceholder.typicode.com/users?${searchParams}`);


// Але Axios дозволяє передавати параметри в окремому об'єкті через властивість params:


// axios.get("https://jsonplaceholder.typicode.com/users", {
//     params: {
//         _limit: 7,
//         _sort: "name"
//     }
// });


// Код стає чистішим та легшим для читання.
// Axios автоматично перетворює об'єкт params у рядок запиту.
// Легко редагувати та додавати нові параметри, без ручного форматування URL.





///////////////////////////////////////////////  ////////////////////////////////////////////////////////








